'use strict'

const zookeeper = require('node-zookeeper-client')
const Logger = require('@dp/logger-container')
const ServerEnv = require('@dp/server-env')

// 先读取zk 服务器
const getZkAddress = function() {
    let serverConfig = ServerEnv.getServerProperties()
    if (serverConfig && serverConfig.zkserver) {
        return serverConfig.zkserver
    } else {
        throw new Error('zkserver not configed!!!')
    }
}

const DEFAULT_CONFIG = {
    sessionTimeout: 30 * 1000,
    spinDelay: 1000,
    retries: 1
}

const NODE_CREATE = 'NODE_CREATED'
const NODE_DELETE = 'NODE_DELETED'
const NODE_CHANGE = 'NODE_DATA_CHANGED'

const createChangeData = (event, data) => {
    return {
        event: event,
        data: data
    }
}

class Client {
    /**
     * @constructor
     * @param {string} zkAddress
     * @param {object} [options] default:{
     *          sessionTimeout: 30 * 1000,
     *          spinDelay: 1000,
     *          retries: 1
     * }
     */
    constructor(zkAddress, options = {}) {
        this.zkOptions = Object.assign({}, DEFAULT_CONFIG, options)
        this.address = zkAddress || getZkAddress()

        // node-zookeeper-client instance
        this._innerClient = null
        this.initPromise = null
        this.watcherCache = {}
    }
    /**
     * @public
     * init client
     * */
    async init() {
        if (!this.initPromise) {
            this.initPromise = this._createClient()
        }
        await this.initPromise
    }

    /**
     * @public
     * 获取zk中的数据， 并且添加watcher
     * zookeeper 每次触发watcher后需要重新添加, 重连后也需要重新watch
     * 此方法内部会保证onData函数一直能够被触发
     * @param {string} path
     * @param {function} [onData] 监听函数 , 会接受一个参数如下
     * {
     *      event: {string} , 'NODE_DELETED', 'NODE_DATA_CHANGED', 'NODE_CREATED'
     *      data: {object}  , 对应的数据,如果是delete ，则为Null
     * }
     * @return{string} zk中的值
     * */
    async getAndWatch(path, onData = () => { }) {
        let logger = Logger('Zookeeper')
        this._addWatcherForPath(path, onData, 'getAndWatch')
        let zkValue = null
        let zkExists = await new Promise((resolve, reject) => {
            this._innerClient.exists(
                path,
                (event) => {
                    let name = event.getName()
                    switch (name) {
                        case NODE_DELETE:
                            onData(createChangeData(name, null))
                            break
                        case NODE_CHANGE:
                        case NODE_CREATE:
                            this.getData(path).then(res => onData(createChangeData(name, res)))
                            break
                    }
                    this.getAndWatch(path, onData)
                },
                (error, stat) => {
                    if (error) {
                        logger.info('exists zk path ' + path + ' error', error.stack)
                        return resolve(false)
                    }
                    resolve(!!stat)
                }
            )
        })

        if (zkExists) {
            zkValue = await this.getData(path)
        } else {
            logger.info('path ' + path + ' not exists')
        }

        return zkValue
    }

    /**
     * 检测某个路径是否存在，并且增加监听函数,监听函数在节点被添加或者删除的时候触发
     * @param {string} path
     * @param {function} onData
     * @return {boolean}
     */
    async existsAndWatch(path, onData = () => { }) {
        this._addWatcherForPath(path, onData, 'existsAndWatch')
        let zkExists = await new Promise((resolve, reject) => {
            this._innerClient.exists(
                path,
                (event) => {
                    let name = event.getName()
                    if (~[NODE_DELETE, NODE_CREATE].indexOf(name)) {
                        onData(createChangeData(name, name !== NODE_DELETE))
                    }
                    this.existsAndWatch(path, onData)
                },
                (error, stat) => {
                    if (error) {
                        return resolve(false)
                    }
                    resolve(!!stat)
                }
            )
        })

        return zkExists
    }

    /**
     * @public
     * 获取值,返回字符串,如果路径不存在或者出错则返回null
     * @param {string} path
     * @return {string} zk中的值
     */
    async getData(path) {
        let logger = Logger('Zookeeper')
        let self = this
        let zkValue = await new Promise(function(resolve, reject) {
            self._innerClient.getData(
                path,
                function(err, data, stat) {
                    if (err || !stat) {
                        logger.info('Zookeeper Load path ' + path + ' Fail.' + (err ? err.stack : ''))
                        return resolve(null)
                    }
                    resolve(data ? data.toString() : null)
                }
            )
        })
        return zkValue
    }

    /**
     * 检查某个路径是否存在
     * @param {string} path
     * @return {boolean}
     */
    async exists(path) {
        let zkExists = await new Promise((resolve, reject) => {
            this._innerClient.exists(
                path,
                (error, stat) => {
                    if (error) {
                        return resolve(false)
                    }
                    resolve(!!stat)
                }
            )
        })
        return zkExists
    }

    /**
     * @public
     * 返回zk实例
     * @return {Zookeeper.Client}
     */
    getClient() {
        return this._innerClient
    }

    /**
     * @private
     * init zk client
     */
    async _createClient() {
        let logger = Logger('Zookeeper')
        let client = this._innerClient = zookeeper.createClient(this.address, this.zkOptions)
        let self = this

        await new Promise(function(resolve, reject) {
            client.once('connected', function() {
                // 把cache中的watcher重新添加一遍
                self._rebindWatchers()
                resolve()
            })
            client.on('connected', function() {
                logger.info('Zookeeper connection: state(connected).')
            })

            function onDisconnect(state) {
                logger.warn('Zookeeper connection: state(' + state + ').')
                client.close()
                // 重新建立client
                self._createClient()
            }

            client.on('expired', function() {
                onDisconnect('expired')
            })
            // 正常的连接断开 client会自己重连
            client.on('disconnected', function() {
                logger.info('Zookeeper connection disconnected')
            })
            client.on('error', function(e) {
                logger.error('Zookeeper connection Error ', e)
                client.close()
                return reject(e)
            });

            [
                'connectedReadOnly',
                'authenticationFailed'
            ].forEach(function(state) {
                client.on(state, function() {
                    logger.warn('Zookeeper connection: state(%s).', state)
                })
            })

            // 开始链接zk
            logger.info('Zookeeper connection: connecting...')
            client.connect()
        })
    }

    /**
     * @private
     * 为某个PATH新增watcher
     * @param {string} path
     * @param {function} listener
     * @param {string} method
     * */
    _addWatcherForPath(path, listener, method) {
        if (!path || !listener || !method) {
            return
        }
        if (!(path in this.watcherCache)) {
            this.watcherCache[path] = []
        }
        let watchers = this.watcherCache[path]
        if (watchers.some(watcher => watcher.listener === listener && watcher.method === method)) {
            // 已经添加过
            return
        }
        watchers.push({
            listener: listener,
            method: method
        })
    }

    /**
     * 重新绑定watchers
     * */
    _rebindWatchers() {
        for (let path in this.watcherCache) {
            let watchers = this.watcherCache[path]
            watchers.forEach(watcher => {
                this[watcher.method](path, watcher.listener)
            })
        }
    }
}

module.exports = Client
