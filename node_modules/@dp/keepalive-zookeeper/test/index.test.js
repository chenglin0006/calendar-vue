'use strict'
jest.mock('node-zookeeper-client')
const NODE_ZK = require('node-zookeeper-client')
const ZK = require('../build')
let client = new ZK()

const SOME_UN_EXISTS_PATH = 'SOME_UN_EXISTS_PATH'
const EXISTS_PATH = 'key1'
const EXISTS_PATH_VALUE = 'value1'

describe('keepalive-zookeeper', () => {
    beforeEach(() => {
        return client.init()
    })
    afterEach(() => {
        NODE_ZK.__mockStorage.delete(SOME_UN_EXISTS_PATH)
    })
    describe('#init', () => {
        it('return promise', () => {
            expect(client.init() instanceof Promise).toBe(true)
        })
    })

    describe('#getAndWatch', () => {
        it('return null when node not exists and watch for create', () => {
            return (async () => {
                let r, j
                let p = new Promise((resolve, reject) => {
                    r = resolve
                    j = reject
                })
                let res = await client.getAndWatch(SOME_UN_EXISTS_PATH, (value) => {
                    try {
                        expect(value.event).toBe('NODE_CREATED')
                        expect(value.data).toBe('some_value')
                    } catch (e) {
                        j(e)
                    }
                    r()
                })
                expect(res).toBe(null)

                NODE_ZK.__mockStorage.set(SOME_UN_EXISTS_PATH, 'some_value')
                await p
                NODE_ZK.__mockStorage.delete(SOME_UN_EXISTS_PATH)
            })()
        })
        it('return the zk string value', () => {
            return client.getAndWatch(EXISTS_PATH).then(value => {
                expect(value).toBe(EXISTS_PATH_VALUE)
            })
        })
        it('add forever listener ', () => {
            return (async () => {
                let count = 0
                let r
                let j
                let p = new Promise((resolve, reject) => {
                    r = resolve
                    j = reject
                })
                await client.getAndWatch(EXISTS_PATH, (value) => {
                    try {
                        count++
                        expect(value.data).toBe('newValue' + count)
                    } catch (e) {
                        j(e)
                    }
                    if (count === 2) {
                        r()
                    }
                })
                NODE_ZK.__mockStorage.set(EXISTS_PATH, 'newValue1')
                setTimeout(() => {
                    NODE_ZK.__mockStorage.set(EXISTS_PATH, 'newValue2')
                }, 100)
                await p
                NODE_ZK.__mockStorage.set(EXISTS_PATH, EXISTS_PATH_VALUE)
            })()
        })
    })

    describe('#getData', () => {
        it('return a promise', () => {
            expect(client.getData('some_path') instanceof Promise).toBe(true)
        })

        it('return null if not exists', () => {
            return client.getData(SOME_UN_EXISTS_PATH).then(value => {
                expect(value).toBe(null)
            })
        })

        it('return zk string value', () => {
            return client.getData(EXISTS_PATH).then(value => {
                expect(value).toBe(EXISTS_PATH_VALUE)
            })
        })
    })

    describe('#existsAndWatch', () => {
        it('return a promise', () => {
            expect(client.existsAndWatch('path') instanceof Promise).toBe(true)
        })

        it('return false when path not exists', () => {
            return client.existsAndWatch(SOME_UN_EXISTS_PATH).then(value => {
                expect(value).toBe(false)
            })
        })

        it('return true when path exists', () => {
            return client.existsAndWatch(EXISTS_PATH).then(value => {
                expect(value).toBe(true)
            })
        })

        it('add forever listener ', () => {
            let PATH = SOME_UN_EXISTS_PATH
            return (async () => {
                let count = 0
                let r
                let j
                let p = new Promise((resolve, reject) => {
                    r = resolve
                    j = reject
                })

                let res = await client.existsAndWatch(PATH, (value) => {
                    let isCreate = (count++) % 2 === 0
                    if (count > 2) {
                        return
                    }
                    try {
                        if (isCreate) {
                            expect(value.event).toBe('NODE_CREATED')
                            expect(value.data).toBe(true)
                        } else {
                            expect(value.event).toBe('NODE_DELETED')
                            expect(value.data).toBe(false)
                        }
                    } catch (e) {
                        j(e)
                    }
                    if (count === 2) {
                        r()
                    }
                })
                expect(res).toBe(false)
                NODE_ZK.__mockStorage.set(PATH, 'some_value')
                setTimeout(() => {
                    NODE_ZK.__mockStorage.delete(PATH)
                }, 100)
                await p
                NODE_ZK.__mockStorage.delete(PATH)
            })()
        })
    })

    describe('exists', () => {
        it('return promise', () => {
            expect(client.exists(SOME_UN_EXISTS_PATH) instanceof Promise).toBe(true)
            expect(client.exists(EXISTS_PATH) instanceof Promise).toBe(true)
        })
        it('return true when node exists', () => {
            return client.exists(EXISTS_PATH).then(res => {
                expect(res).toBe(true)
            })
        })
        it('return false when node exists', () => {
            return client.exists(SOME_UN_EXISTS_PATH).then(res => {
                expect(res).toBe(false)
            })
        })
    })
})
