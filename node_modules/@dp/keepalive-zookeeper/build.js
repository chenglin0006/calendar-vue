'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const zookeeper = require('node-zookeeper-client');
const Logger = require('@dp/logger-container');
const ServerEnv = require('@dp/server-env');

// 先读取zk 服务器
const getZkAddress = function () {
    let serverConfig = ServerEnv.getServerProperties();
    if (serverConfig && serverConfig.zkserver) {
        return serverConfig.zkserver;
    } else {
        throw new Error('zkserver not configed!!!');
    }
};

const DEFAULT_CONFIG = {
    sessionTimeout: 30 * 1000,
    spinDelay: 1000,
    retries: 1
};

const NODE_CREATE = 'NODE_CREATED';
const NODE_DELETE = 'NODE_DELETED';
const NODE_CHANGE = 'NODE_DATA_CHANGED';

const createChangeData = (event, data) => {
    return {
        event: event,
        data: data
    };
};

class Client {
    /**
     * @constructor
     * @param {string} zkAddress
     * @param {object} [options] default:{
     *          sessionTimeout: 30 * 1000,
     *          spinDelay: 1000,
     *          retries: 1
     * }
     */
    constructor(zkAddress) {
        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        this.zkOptions = Object.assign({}, DEFAULT_CONFIG, options);
        this.address = zkAddress || getZkAddress();

        // node-zookeeper-client instance
        this._innerClient = null;
        this.initPromise = null;
        this.watcherCache = {};
    }
    /**
     * @public
     * init client
     * */
    init() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (!_this.initPromise) {
                _this.initPromise = _this._createClient();
            }
            yield _this.initPromise;
        })();
    }

    /**
     * @public
     * 获取zk中的数据， 并且添加watcher
     * zookeeper 每次触发watcher后需要重新添加, 重连后也需要重新watch
     * 此方法内部会保证onData函数一直能够被触发
     * @param {string} path
     * @param {function} [onData] 监听函数 , 会接受一个参数如下
     * {
     *      event: {string} , 'NODE_DELETED', 'NODE_DATA_CHANGED', 'NODE_CREATED'
     *      data: {object}  , 对应的数据,如果是delete ，则为Null
     * }
     * @return{string} zk中的值
     * */
    getAndWatch(path) {
        var _arguments = arguments,
            _this2 = this;

        return _asyncToGenerator(function* () {
            let onData = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : function () {};

            let logger = Logger('Zookeeper');
            _this2._addWatcherForPath(path, onData, 'getAndWatch');
            let zkValue = null;
            let zkExists = yield new Promise(function (resolve, reject) {
                _this2._innerClient.exists(path, function (event) {
                    let name = event.getName();
                    switch (name) {
                        case NODE_DELETE:
                            onData(createChangeData(name, null));
                            break;
                        case NODE_CHANGE:
                        case NODE_CREATE:
                            _this2.getData(path).then(function (res) {
                                return onData(createChangeData(name, res));
                            });
                            break;
                    }
                    _this2.getAndWatch(path, onData);
                }, function (error, stat) {
                    if (error) {
                        logger.info('exists zk path ' + path + ' error', error.stack);
                        return resolve(false);
                    }
                    resolve(!!stat);
                });
            });

            if (zkExists) {
                zkValue = yield _this2.getData(path);
            } else {
                logger.info('path ' + path + ' not exists');
            }

            return zkValue;
        })();
    }

    /**
     * 检测某个路径是否存在，并且增加监听函数,监听函数在节点被添加或者删除的时候触发
     * @param {string} path
     * @param {function} onData
     * @return {boolean}
     */
    existsAndWatch(path) {
        var _arguments2 = arguments,
            _this3 = this;

        return _asyncToGenerator(function* () {
            let onData = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : function () {};

            _this3._addWatcherForPath(path, onData, 'existsAndWatch');
            let zkExists = yield new Promise(function (resolve, reject) {
                _this3._innerClient.exists(path, function (event) {
                    let name = event.getName();
                    if (~[NODE_DELETE, NODE_CREATE].indexOf(name)) {
                        onData(createChangeData(name, name !== NODE_DELETE));
                    }
                    _this3.existsAndWatch(path, onData);
                }, function (error, stat) {
                    if (error) {
                        return resolve(false);
                    }
                    resolve(!!stat);
                });
            });

            return zkExists;
        })();
    }

    /**
     * @public
     * 获取值,返回字符串,如果路径不存在或者出错则返回null
     * @param {string} path
     * @return {string} zk中的值
     */
    getData(path) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            let logger = Logger('Zookeeper');
            let self = _this4;
            let zkValue = yield new Promise(function (resolve, reject) {
                self._innerClient.getData(path, function (err, data, stat) {
                    if (err || !stat) {
                        logger.info('Zookeeper Load path ' + path + ' Fail.' + (err ? err.stack : ''));
                        return resolve(null);
                    }
                    resolve(data ? data.toString() : null);
                });
            });
            return zkValue;
        })();
    }

    /**
     * 检查某个路径是否存在
     * @param {string} path
     * @return {boolean}
     */
    exists(path) {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            let zkExists = yield new Promise(function (resolve, reject) {
                _this5._innerClient.exists(path, function (error, stat) {
                    if (error) {
                        return resolve(false);
                    }
                    resolve(!!stat);
                });
            });
            return zkExists;
        })();
    }

    /**
     * @public
     * 返回zk实例
     * @return {Zookeeper.Client}
     */
    getClient() {
        return this._innerClient;
    }

    /**
     * @private
     * init zk client
     */
    _createClient() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            let logger = Logger('Zookeeper');
            let client = _this6._innerClient = zookeeper.createClient(_this6.address, _this6.zkOptions);
            let self = _this6;

            yield new Promise(function (resolve, reject) {
                client.once('connected', function () {
                    // 把cache中的watcher重新添加一遍
                    self._rebindWatchers();
                    resolve();
                });
                client.on('connected', function () {
                    logger.info('Zookeeper connection: state(connected).');
                });

                function onDisconnect(state) {
                    logger.warn('Zookeeper connection: state(' + state + ').');
                    client.close();
                    // 重新建立client
                    self._createClient();
                }

                client.on('expired', function () {
                    onDisconnect('expired');
                });
                // 正常的连接断开 client会自己重连
                client.on('disconnected', function () {
                    logger.info('Zookeeper connection disconnected');
                });
                client.on('error', function (e) {
                    logger.error('Zookeeper connection Error ', e);
                    client.close();
                    return reject(e);
                });

                ['connectedReadOnly', 'authenticationFailed'].forEach(function (state) {
                    client.on(state, function () {
                        logger.warn('Zookeeper connection: state(%s).', state);
                    });
                });

                // 开始链接zk
                logger.info('Zookeeper connection: connecting...');
                client.connect();
            });
        })();
    }

    /**
     * @private
     * 为某个PATH新增watcher
     * @param {string} path
     * @param {function} listener
     * @param {string} method
     * */
    _addWatcherForPath(path, listener, method) {
        if (!path || !listener || !method) {
            return;
        }
        if (!(path in this.watcherCache)) {
            this.watcherCache[path] = [];
        }
        let watchers = this.watcherCache[path];
        if (watchers.some(watcher => watcher.listener === listener && watcher.method === method)) {
            // 已经添加过
            return;
        }
        watchers.push({
            listener: listener,
            method: method
        });
    }

    /**
     * 重新绑定watchers
     * */
    _rebindWatchers() {
        for (let path in this.watcherCache) {
            let watchers = this.watcherCache[path];
            watchers.forEach(watcher => {
                this[watcher.method](path, watcher.listener);
            });
        }
    }
}

module.exports = Client;
